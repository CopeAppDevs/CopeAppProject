// Generated by CoffeeScript 1.8.0
(function() {
  var DIVIDER, HEADER, OUR_SOURCE, SOURCE, UNKNOWN, colors, endsWith, escapeHtml, formatExceptionLines, formatters, isString, parseException, parseExceptionLine, path, stripColors,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  colors = require('colors/safe');

  HEADER = "header";

  SOURCE = "source";

  OUR_SOURCE = "our-source";

  UNKNOWN = "unknown";

  DIVIDER = "divider";

  stripColors = require('./utils').stripColors;

  escapeHtml = function(html) {
    return String(html).replace(/&(?!\w+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };

  isString = function(value) {
    return typeof value === 'string' || value && typeof value === 'object' && toString.call(value) === '[object String]' || false;
  };

  endsWith = function(str, suffix) {
    return str.slice(-suffix.length) === suffix;
  };

  parseExceptionLine = (function() {
    var STACK_LINE_NO_FN_RE, STACK_LINE_RE;
    STACK_LINE_RE = /(\s*)at\s*([^\s]*)\s*\((.*?):(\d*):(\d*)\)/;
    STACK_LINE_NO_FN_RE = /(\s*)at\s*(.*?):(\d*):(\d*)/;
    return function(line) {
      var match;
      match = STACK_LINE_RE.exec(line);
      if (match) {
        return {
          indent: match[1],
          fn: match[2],
          filename: match[3],
          line: match[4],
          column: match[5]
        };
      } else {
        match = STACK_LINE_NO_FN_RE.exec(line);
        if (match) {
          return {
            indent: match[1],
            filename: match[2],
            line: match[3],
            column: match[4]
          };
        } else {
          return null;
        }
      }
    };
  })();

  parseException = (function() {
    var DIVIDERS;
    DIVIDERS = ['    <<< async stack >>>', '    <<< raw stack >>>', '---------------------------------------------'];
    return function(exception, options) {
      var basepath, basepathReplacement, endOfHeader, exceptionText, lines, value, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      basepath = (_ref = options.basepath) != null ? _ref : process.cwd();
      if (isString(basepath) && !endsWith(basepath, path.sep)) {
        basepath += path.sep;
      }
      basepathReplacement = (_ref1 = options.basepathReplacement) != null ? _ref1 : "." + path.sep;
      exceptionText = isString(exception) ? exception : exception.stack != null ? exception.stack : "" + exception;
      value = stripColors(exceptionText);
      lines = value.split('\n');
      endOfHeader = false;
      return lines.map(function(line) {
        var filename, parsed, type;
        parsed = null;
        if (__indexOf.call(DIVIDERS, line) >= 0) {
          endOfHeader = true;
          type = DIVIDER;
        } else {
          parsed = parseExceptionLine(line);
          if (parsed) {
            filename = parsed.filename;
            endOfHeader = true;
            type = SOURCE;
            if (filename.indexOf('node_modules') === -1 && filename[isString(basepath) ? 'indexOf' : 'search'](basepath) !== -1) {
              type = OUR_SOURCE;
            }
          }
        }
        if (!endOfHeader && !type) {
          type = HEADER;
        }
        if (!type) {
          type = UNKNOWN;
        }
        if (type === SOURCE || type === OUR_SOURCE) {
          line = line.replace(basepath, basepathReplacement);
          parsed.filename = parsed.filename.replace(basepath, basepathReplacement);
        }
        return {
          line: line,
          parsed: parsed,
          type: type
        };
      });
    };
  })();

  formatExceptionLines = function(exception, options, lineFn) {
    var lines;
    lines = parseException(exception, options);
    if ((options.maxLines != null) && lines.length > options.maxLines) {
      lines = lines.slice(0, options.maxLines + 1);
      lines.push({
        line: "    [truncated]",
        type: DIVIDER
      });
    }
    lines = lines.map(lineFn);
    return lines.join('\n');
  };

  formatters = {
    html: (function() {
      var INLINE_STYLES;
      INLINE_STYLES = {};
      INLINE_STYLES[OUR_SOURCE] = "white-space:nowrap; font-weight:bold; color: #800";
      INLINE_STYLES[SOURCE] = "white-space:nowrap; color: #888";
      INLINE_STYLES[DIVIDER] = "white-space:nowrap; color: #000";
      return function(exception, options) {
        var html, style;
        if (options == null) {
          options = {};
        }
        html = formatExceptionLines(exception, options, function(_arg) {
          var line, style, type, _ref;
          line = _arg.line, type = _arg.type;
          line = escapeHtml(line);
          style = options.inlineStyle ? "style='" + ((_ref = INLINE_STYLES[type]) != null ? _ref : '') + "'" : "class=" + type;
          switch (type) {
            case HEADER:
              return "<h2 " + style + ">" + line + "</h2>";
            default:
              return "<span " + style + ">" + line + "</span><br />";
          }
        });
        style = options.inlineStyle ? "style='font-family: monospace'" : "class='exception'";
        return "<div " + style + ">" + html + "</div>";
      };
    })(),
    ascii: function(exception, options) {
      if (options == null) {
        options = {};
      }
      return formatExceptionLines(exception, options, function(_arg) {
        var line, type;
        line = _arg.line, type = _arg.type;
        switch (type) {
          case OUR_SOURCE:
            if (line[0] === ' ') {
              return "*" + line.slice(1);
            } else {
              return line;
            }
            break;
          default:
            return line;
        }
      });
    },
    ansi: (function() {
      var colorizeLine;
      colorizeLine = function(parsed) {
        var file;
        file = "" + parsed.filename + ":" + parsed.line + ":" + parsed.column;
        if (parsed.fn != null) {
          return "" + parsed.indent + "at " + (colors.magenta(parsed.fn)) + " (" + (colors.cyan(file)) + ")";
        } else {
          return "" + parsed.indent + "at (" + (colors.cyan(file)) + ")";
        }
      };
      return function(exception, options) {
        if (options == null) {
          options = {};
        }
        return formatExceptionLines(exception, options, function(_arg) {
          var line, parsed, type, _ref;
          line = _arg.line, type = _arg.type, parsed = _arg.parsed;
          switch (type) {
            case OUR_SOURCE:
              if ((_ref = options.colors) != null ? _ref : true) {
                return colors.bold(colorizeLine(parsed));
              } else {
                return colors.bold(line);
              }
              break;
            default:
              return line;
          }
        });
      };
    })()
  };

  module.exports = function(exception, options) {
    var format, _ref;
    if (options == null) {
      options = {};
    }
    format = (_ref = options.format) != null ? _ref : 'ascii';
    return formatters[format](exception, options);
  };

  module.exports.parseExceptionLine = parseExceptionLine;

}).call(this);
